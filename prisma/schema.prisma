generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id           String              @id @default(uuid())
  email        String              @unique
  passwordHash String
  tenantId     String?             @db.VarChar(64)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  sessions     ComparisonSession[]
  documents    Document[]
  @@index([email])
}

model ComparisonSession {
  id          String               @id @default(uuid())
  userId      String
  tenantId    String?              @db.VarChar(64)
  idempotencyKey String?           @db.VarChar(128)
  status      SessionStatus        @default(PENDING)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  user        User                 @relation(fields: [userId], references: [id])
  documents   Document[]
  normalized  NormalizedAttribute[]
  @@unique([userId, idempotencyKey])
  @@index([userId])
  @@index([userId, status])
  @@index([createdAt])
}

model Document {
  id           String           @id @default(uuid())
  userId       String
  sessionId    String
  s3Key        String           @unique
  filename     String
  mimeType     String
  sizeBytes    Int
  pageCount    Int?
  status       DocumentStatus   @default(UPLOADED)
  expiresAt    DateTime
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  user         User             @relation(fields: [userId], references: [id])
  session      ComparisonSession @relation(fields: [sessionId], references: [id])
  extracted    ExtractedField[]
  normalized   NormalizedAttribute[]
  @@index([sessionId])
  @@index([userId])
}

model ExtractedField {
  id         String   @id @default(uuid())
  documentId String
  name       String
  value      String
  source     String
  createdAt  DateTime @default(now())
  document   Document @relation(fields: [documentId], references: [id])
  @@index([documentId])
}

model NormalizedAttribute {
  id          String               @id @default(uuid())
  sessionId   String
  documentId  String
  key         String
  displayName String
  value       String
  createdAt   DateTime             @default(now())
  session     ComparisonSession    @relation(fields: [sessionId], references: [id])
  document    Document             @relation(fields: [documentId], references: [id])
  @@index([sessionId, key])
}

enum SessionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum DocumentStatus {
  UPLOADED
  EXTRACTED
  FAILED
}

/// Product feedback from /feedback form (Neon/Prisma; no auth required for insert).
model FeedbackResponse {
  id                String   @id @default(uuid())
  createdAt         DateTime @default(now()) @map("created_at")
  role              String?
  resumesPerRole    String?  @map("resumes_per_role")
  previousMethod    String?  @map("previous_method")
  painPoint         String?  @map("pain_point")
  usefulnessRating  Int?     @map("usefulness_rating")
  valuableFeatures  String[] @map("valuable_features")
  confidenceAfter   String?  @map("confidence_after")
  missingFeatures   String[] @map("missing_features")
  missingOther      String?  @map("missing_other")
  openFeedback      String?  @map("open_feedback")
  disappearReaction String?  @map("disappear_reaction")
  wouldRecommend   String?  @map("would_recommend")
  email             String?

  @@map("feedback_responses")
}
